// Coffe Class fixed for Closure Compiler by Este.js
// Generated by CoffeeScript 1.4.0
var Person, requiredValidator, trimSetter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

trimSetter = function(value) {
  return goog.string.trim(value || '');
};

requiredValidator = function(value) {
  return value && goog.string.trim(value).length;
};



  

  var Person = function(json, randomStringGenerator) {
    Person.superClass_.constructor.call(this, json, randomStringGenerator);
  }

  goog.inherits(Person, este.Model);

  Person.prototype.defaults = {
    'defaultFoo': 1
  };

  Person.prototype.schema = {
    'firstName': {
      'set': trimSetter,
      'validators': {
        'required': requiredValidator
      }
    },
    'lastName': {
      'validators': {
        'required': requiredValidator
      }
    },
    'name': {
      'meta': function(self) {
        return self.get('firstName') + ' ' + self.get('lastName');
      }
    },
    'age': {
      'get': function(age) {
        return Number(age);
      }
    }
  };

  

suite('este.Model', function() {
  var json, person;
  json = null;
  person = null;
  setup(function() {
    var idGenerator;
    json = {
      'firstName': 'Joe',
      'lastName': 'Satriani',
      'age': 55
    };
    idGenerator = function() {
      return 1;
    };
    return person = new Person(json, idGenerator);
  });
  suite('constructor', function() {
    test('should work', function() {
      return assert.instanceOf(person, Person);
    });
    test('should assign clientId', function() {
      return assert.equal(person.get('clientId'), 1);
    });
    test('should assign id', function() {
      person = new Person({
        id: 'foo'
      });
      return assert.equal(person.get('id'), 'foo');
    });
    test('should create attributes', function() {
      person = new Person;
      return assert.isUndefined(person.get('firstName'));
    });
    test('should return passed attributes', function() {
      assert.equal(person.get('firstName'), 'Joe');
      assert.equal(person.get('lastName'), 'Satriani');
      return assert.equal(person.get('age'), 55);
    });
    test('should set defaults', function() {
      return assert.equal(person.get('defaultFoo'), 1);
    });
    return test('should set defaults before json', function() {
      person = new Person({
        'defaultFoo': 2
      });
      return assert.equal(person.get('defaultFoo'), 2);
    });
  });
  suite('instance', function() {
    return test('should have string urn property', function() {
      return assert.isString(person.urn);
    });
  });
  suite('set and get', function() {
    test('should work for one attribute', function() {
      person.set('age', 35);
      return assert.strictEqual(person.get('age'), 35);
    });
    return test('should work for attributes', function() {
      person.set({
        'age': 35,
        'firstName': 'Pepa'
      });
      assert.strictEqual(person.get('age'), 35);
      return assert.strictEqual(person.get('firstName'), 'Pepa');
    });
  });
  suite('get', function() {
    return test('should accept array and return object', function() {
      return assert.deepEqual(person.get(['age', 'firstName']), {
        'age': 55,
        'firstName': 'Joe'
      });
    });
  });
  suite('set', function() {
    return test('should set valid keys, ignore invalids', function() {
      assert.equal(person.get('firstName'), 'Joe');
      person.set({
        firstName: 'Pepa',
        lastName: ''
      });
      assert.equal(person.get('firstName'), 'Pepa');
      return assert.equal(person.get('lastName'), 'Satriani');
    });
  });
  suite('toJson', function() {
    suite('without json', function() {
      test('true should not return meta name nor clientId', function() {
        person = new Person;
        json = person.toJson(true);
        assert.isUndefined(json.clientId);
        return assert.isUndefined(json.name);
      });
      return test('false should return clientId and meta name', function() {
        person = new Person(null, function() {
          return 1;
        });
        json = person.toJson();
        return assert.deepEqual(json, {
          'clientId': 1,
          'name': 'undefined undefined',
          'defaultFoo': 1
        });
      });
    });
    suite('with json', function() {
      test('false should return clientId and meta name', function() {
        json = person.toJson();
        return assert.deepEqual(json, {
          'clientId': 1,
          'firstName': 'Joe',
          'lastName': 'Satriani',
          'name': 'Joe Satriani',
          'age': 55,
          'defaultFoo': 1
        });
      });
      return test('true, true should not return id', function() {
        var idGenerator;
        json = {
          'id': 123,
          'firstName': 'Joe',
          'lastName': 'Satriani',
          'age': 55
        };
        idGenerator = function() {
          return 1;
        };
        person = new Person(json, idGenerator);
        json = person.toJson(true, true);
        return assert.deepEqual(json, {
          'firstName': 'Joe',
          'lastName': 'Satriani',
          'age': 55,
          'defaultFoo': 1
        });
      });
    });
    return suite('defined on model', function() {
      return test('should be called', function() {
        var model;
        model = new este.Model;
        model.set('a', {
          toJson: function() {
            return 'b';
          }
        });
        return assert.deepEqual(model.toJson(true, true), {
          a: 'b'
        });
      });
    });
  });
  suite('has', function() {
    test('should work', function() {
      assert.isTrue(person.has('age'));
      return assert.isFalse(person.has('fooBlaBlaFoo'));
    });
    test('should work even for keys which are defined on Object.prototype.', function() {
      assert.isFalse(person.has('toString'));
      assert.isFalse(person.has('constructor'));
      return assert.isFalse(person.has('__proto__'));
    });
    return test('should work for meta properties too', function() {
      return assert.isTrue(person.has('name'));
    });
  });
  suite('remove', function() {
    test('should work', function() {
      assert.isFalse(person.has('fok'));
      assert.isFalse(person.remove('fok'));
      assert.isTrue(person.has('age'));
      assert.isTrue(person.remove('age'));
      return assert.isFalse(person.has('age'));
    });
    return test('should call setParentEventTarget null on removed EventTargets', function() {
      var target;
      target = new goog.events.EventTarget;
      person.set('foo', target);
      person.remove('foo');
      return assert.isNull(target.getParentEventTarget());
    });
  });
  suite('schema', function() {
    suite('set', function() {
      return test('should work as formater before set', function() {
        person.set('firstName', '  whitespaces ');
        return assert.equal(person.get('firstName'), 'whitespaces');
      });
    });
    return suite('get', function() {
      return test('should work as formater after get', function() {
        person.set('age', '1d23');
        return assert.isNumber(person.get('age'));
      });
    });
  });
  suite('change event', function() {
    test('should be dispatched if value change', function(done) {
      goog.events.listenOnce(person, 'change', function(e) {
        assert.deepEqual(e.changed, {
          age: 'foo'
        });
        assert.equal(e.model, person);
        return done();
      });
      return person.set('age', 'foo');
    });
    test('should not be dispatched if value hasnt changed', function() {
      var called;
      called = false;
      goog.events.listenOnce(person, 'change', function(e) {
        return called = true;
      });
      person.set('age', 55);
      return assert.isFalse(called);
    });
    return test('should be dispatched if value is removed', function() {
      var called;
      called = false;
      goog.events.listenOnce(person, 'change', function(e) {
        return called = true;
      });
      person.remove('age');
      return assert.isTrue(called);
    });
  });
  suite('update event', function() {
    test('should be dispatched if value change', function(done) {
      goog.events.listenOnce(person, 'update', function(e) {
        return done();
      });
      return person.set('age', 'foo');
    });
    test('should not be dispatched if value hasnt changed', function() {
      var called;
      called = false;
      goog.events.listenOnce(person, 'update', function(e) {
        return called = true;
      });
      person.set('age', 55);
      return assert.isFalse(called);
    });
    return test('should be dispatched if value is removed', function() {
      var called;
      called = false;
      goog.events.listenOnce(person, 'update', function(e) {
        return called = true;
      });
      person.remove('age');
      return assert.isTrue(called);
    });
  });
  suite('meta', function() {
    return test('should define meta attribute', function() {
      return assert.equal(person.get('name'), 'Joe Satriani');
    });
  });
  suite('bubbling events', function() {
    return test('from inner model should work', function() {
      var called, innerModel;
      called = 0;
      innerModel = new Person;
      person.set('inner', innerModel);
      goog.events.listen(person, 'change', function(e) {
        return called++;
      });
      innerModel.set('name', 'foo');
      person.remove('inner', innerModel);
      innerModel.set('name', 'foo');
      return assert.equal(called, 2);
    });
  });
  return suite('errors', function() {
    suite('set', function() {
      return test('should return correct errors', function() {
        var errors;
        errors = person.set();
        assert.isNull(errors);
        errors = person.set('firstName', null);
        assert.deepEqual(errors, {
          firstName: {
            required: true
          }
        });
        assert.equal(person.get('firstName'), 'Joe');
        errors = person.set('firstName', 'Pepa');
        assert.deepEqual(errors, null);
        errors = person.set({
          'firstName': 'Pepa',
          'lastName': 'Zdepa'
        });
        assert.deepEqual(errors, null);
        errors = person.set({
          'firstName': null,
          'lastName': null
        });
        return assert.deepEqual(errors, {
          firstName: {
            required: true
          },
          lastName: {
            required: true
          }
        });
      });
    });
    return suite('validate', function() {
      return test('should return correct errors', function() {
        var errors;
        errors = person.validate();
        assert.isNull(errors);
        person = new Person;
        errors = person.validate();
        assert.deepEqual(errors, {
          firstName: {
            required: true
          },
          lastName: {
            required: true
          }
        });
        person.set('firstName', 'Pepa');
        errors = person.validate();
        return assert.deepEqual(errors, {
          lastName: {
            required: true
          }
        });
      });
    });
  });
});
